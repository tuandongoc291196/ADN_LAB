# Mutations for ADN Lab Firebase Data Connect - Users and Roles
# Chat functionality remains in Firestore

# ====== ROLE MUTATIONS ======

# Create a new role (admin only)
mutation CreateRole(
  $id: String!
  $name: String!
  $description: String
  $permissions: String
) @auth(level: USER) {
  role_insert(data: {
    id: $id
    name: $name
    description: $description
    permissions: $permissions
    isActive: true
  })
}

# Update role (admin only)
mutation UpdateRole(
  $roleId: String!
  $name: String
  $description: String
  $permissions: String
  $isActive: Boolean
) @auth(level: USER) {
  role_update(
    key: { id: $roleId }
    data: {
      name: $name
      description: $description
      permissions: $permissions
      isActive: $isActive
      updatedAt_expr: "request.time"
    }
  )
}

# Deactivate role (admin only)
mutation DeactivateRole($roleId: String!) @auth(level: USER) {
  role_update(
    key: { id: $roleId }
    data: { 
      isActive: false
      updatedAt_expr: "request.time"
    }
  )
}

# ====== USER MUTATIONS ======

# Create or update user (upsert) - with new role system
mutation UpsertUser(
  $fullname: String!
  $email: String!
  $authProvider: String!
  $gender: String
  $avatar: String
  $phone: String
  $addressShipping: String
  $roleId: String
  # Legacy fields for backward compatibility
  $isAdmin: Boolean
  $roleString: String
) @auth(level: USER) {
  user_upsert(data: {
    id_expr: "auth.uid"
    fullname: $fullname
    email: $email
    authProvider: $authProvider
    gender: $gender
    avatar: $avatar
    phone: $phone
    addressShipping: $addressShipping
    roleId: $roleId
    isAdmin: $isAdmin
    roleString: $roleString
  })
}

# Update last login time
mutation UpdateLastLogin @auth(level: USER) {
  user_update(
    key: { id_expr: "auth.uid" }
    data: { lastLogin_expr: "request.time" }
  )
}

# Update user profile
mutation UpdateUserProfile(
  $fullname: String
  $gender: String
  $phone: String
  $addressShipping: String
) @auth(level: USER) {
  user_update(
    key: { id_expr: "auth.uid" }
    data: {
      fullname: $fullname
      gender: $gender
      phone: $phone
      addressShipping: $addressShipping
    }
  )
}

# Admin: Update user role (new role system)
mutation UpdateUserRole($userId: String!, $roleId: String!) @auth(level: USER) {
  user_update(
    key: { id: $userId }
    data: { 
      roleId: $roleId
      # Update legacy fields for backward compatibility
      isAdmin: false # Will be updated based on role
      roleString: "" # Will be updated based on role name
    }
  )
}

# Admin: Legacy role update (for backward compatibility)
mutation UpdateUserRoleLegacy($userId: String!, $roleString: String!, $isAdmin: Boolean!) @auth(level: USER) {
  user_update(
    key: { id: $userId }
    data: { 
      roleString: $roleString, 
      isAdmin: $isAdmin 
    }
  )
}

# Admin: Update user account status
mutation UpdateAccountStatus($userId: String!, $accountStatus: String!) @auth(level: USER) {
  user_update(
    key: { id: $userId }
    data: { accountStatus: $accountStatus }
  )
}

# Admin: Assign role to multiple users
mutation BulkAssignRole($userIds: [String!]!, $roleId: String!) @auth(level: USER) {
  user_updateMany(
    where: { id: { in: $userIds } }
    data: { roleId: $roleId }
  )
}
